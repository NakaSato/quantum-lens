
import { jsPDF } from "jspdf";
import { Complex, Gate } from "../types";

interface ReportConfig {
  studentName: string;
  projectTitle: string;
  password?: string;
  amplitudes: Complex[];
  gates: (Gate | null)[][];
  numQubits: number;
}

export const generatePDFReport = (config: ReportConfig) => {
  const { studentName, projectTitle, password, amplitudes, gates, numQubits } = config;

  // Initialize PDF
  // Note: Standard jspdf from esm.sh typically includes encryption support in the default build.
  // If not, password might be ignored, but we attempt to set it.
  const doc = new jsPDF({
    encryption: password ? {
      userPassword: password,
      ownerPassword: password,
      userPermissions: ["print", "copy", "modify", "annot-forms"]
    } : undefined
  });

  const pageWidth = doc.internal.pageSize.width;
  const margin = 20;
  let y = 20;

  const addText = (text: string, size: number = 10, style: string = 'normal', color: string = '#000000') => {
    doc.setFontSize(size);
    doc.setFont("helvetica", style);
    doc.setTextColor(color);
    
    // Simple word wrap
    const lines = doc.splitTextToSize(text, pageWidth - margin * 2);
    doc.text(lines, margin, y);
    y += lines.length * (size * 0.5) + 2; 
  };

  const addLine = () => {
    doc.setDrawColor(200, 200, 200);
    doc.line(margin, y, pageWidth - margin, y);
    y += 10;
  };

  const checkPageBreak = (neededSpace: number) => {
    if (y + neededSpace > doc.internal.pageSize.height - margin) {
      doc.addPage();
      y = 20;
    }
  };

  // --- Header ---
  doc.setFillColor(240, 245, 250); // Light blue bg
  doc.rect(0, 0, pageWidth, 40, 'F');
  
  y = 15;
  doc.setFontSize(22);
  doc.setFont("helvetica", "bold");
  doc.setTextColor(40, 60, 80);
  doc.text("Quantum Physics Lab Report", margin, y);
  
  y += 10;
  doc.setFontSize(10);
  doc.setFont("helvetica", "normal");
  doc.setTextColor(100, 100, 100);
  doc.text("Generated by QuantumLens Environment", margin, y);

  y = 50;

  // --- Student Info ---
  addText(`Project Title: ${projectTitle}`, 16, 'bold', '#1e293b');
  y += 2;
  addText(`Student Name: ${studentName || "Anonymous Researcher"}`, 12, 'normal', '#334155');
  addText(`Date: ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString()}`, 10, 'italic', '#64748b');
  
  y += 5;
  addLine();

  // --- 1. Circuit Schematic (Text Representation) ---
  checkPageBreak(60);
  addText("1. Circuit Configuration", 14, 'bold', '#0f172a');
  y += 5;

  doc.setFont("courier", "normal");
  doc.setFontSize(9);
  doc.setFillColor(248, 250, 252);
  
  // Build simple text schematic
  let schematicHeight = 0;
  const schematicLines = [];
  
  for(let q = 0; q < numQubits; q++) {
      let line = `q${q} : |0> ──`;
      gates.forEach(step => {
          const gate = step[q];
          const isControl = step.some(g => g?.control === q);
          
          if (gate) {
              line += `[ ${gate.type}${gate.control !== undefined ? `(c${gate.control})` : ''} ]──`;
          } else if (isControl) {
              // Find who is target
              const targetGate = step.find(g => g?.control === q);
              line += `─ ●(->${targetGate?.target}) ─`;
          } else {
              line += `───────`;
          }
      });
      line += " M";
      schematicLines.push(line);
  }

  // Draw Schematic Box
  const boxHeight = schematicLines.length * 7 + 10;
  doc.rect(margin, y, pageWidth - margin*2, boxHeight, 'F');
  doc.setDrawColor(200, 200, 200);
  doc.rect(margin, y, pageWidth - margin*2, boxHeight, 'S');
  
  y += 7;
  schematicLines.forEach(line => {
      doc.text(line, margin + 5, y);
      y += 7;
  });
  y += 10;

  // --- 2. Statevector Analysis ---
  doc.setFont("helvetica", "normal");
  checkPageBreak(80);
  addText("2. Theoretical State Analysis", 14, 'bold', '#0f172a');
  y += 5;

  // Table Header
  doc.setFontSize(9);
  doc.setTextColor(100, 100, 100);
  doc.text("Basis State", margin, y);
  doc.text("Amplitude", margin + 40, y);
  doc.text("Probability", margin + 90, y);
  doc.text("Phase (rad)", margin + 140, y);
  y += 2;
  doc.line(margin, y, pageWidth - margin, y);
  y += 5;

  doc.setTextColor(0, 0, 0);
  doc.setFontSize(10);

  const significantStates = amplitudes
    .map((amp, idx) => ({ 
        idx, 
        amp, 
        prob: amp.r*amp.r + amp.i*amp.i,
        phase: Math.atan2(amp.i, amp.r)
    }))
    .filter(s => s.prob > 0.0001);

  significantStates.forEach(state => {
      checkPageBreak(10);
      const label = `|${state.idx.toString(2).padStart(numQubits, '0')}>`;
      const ampStr = `${state.amp.r.toFixed(3)} ${state.amp.i >= 0 ? '+' : ''}${state.amp.i.toFixed(3)}i`;
      const probStr = `${(state.prob * 100).toFixed(2)}%`;
      const phaseStr = `${state.phase.toFixed(3)} π`; // Normalized roughly in mind, but let's print raw rad or pi factor? Label said rad.
      // Let's use π units for niceness
      const phasePi = (state.phase / Math.PI).toFixed(3) + " π";

      doc.text(label, margin, y);
      doc.text(ampStr, margin + 40, y);
      doc.text(probStr, margin + 90, y);
      doc.text(phasePi, margin + 140, y);
      y += 6;
  });

  if (significantStates.length === 0) {
      doc.text("System in zero state (should not happen mathematically).", margin, y);
      y += 10;
  }
  y += 5;

  // --- 3. Experimental Simulation ---
  checkPageBreak(80);
  addText("3. Experimental Simulation (1024 Shots)", 14, 'bold', '#0f172a');
  y += 5;

  // Run a quick simulation for the report
  const shots = 1024;
  const numStates = amplitudes.length;
  const counts = new Array(numStates).fill(0);
  const probs = amplitudes.map(c => c.r * c.r + c.i * c.i);
  const cdf = new Array(numStates).fill(0);
  cdf[0] = probs[0];
  for (let i = 1; i < numStates; i++) cdf[i] = cdf[i - 1] + probs[i];

  for (let k = 0; k < shots; k++) {
      const r = Math.random();
      let outcome = numStates - 1;
      for (let j = 0; j < numStates - 1; j++) {
          if (r < cdf[j]) { outcome = j; break; }
      }
      counts[outcome]++;
  }

  // Draw Bar Chart
  const chartHeight = 60;
  const chartWidth = pageWidth - margin * 2;
  const barWidth = (chartWidth / numStates) * 0.8;
  const maxCount = Math.max(...counts);
  const scale = maxCount > 0 ? (chartHeight - 10) / maxCount : 0;

  // Axis
  doc.setDrawColor(0, 0, 0);
  doc.line(margin, y + chartHeight, margin + chartWidth, y + chartHeight); // X axis
  doc.line(margin, y, margin, y + chartHeight); // Y axis

  doc.setFontSize(8);
  doc.setTextColor(80, 80, 80);

  counts.forEach((count, i) => {
      if (count === 0 && numStates > 16) return; // Skip drawing empty bars if too many states
      
      const barH = count * scale;
      const xPos = margin + 5 + i * (chartWidth / numStates);
      
      doc.setFillColor(34, 211, 238); // Cyan
      doc.rect(xPos, y + chartHeight - barH, barWidth, barH, 'F');
      
      // Label
      if (numStates <= 16 || count > maxCount * 0.1) {
         doc.text(i.toString(2).padStart(numQubits, '0'), xPos, y + chartHeight + 4, { angle: 45 });
      }
  });

  y += chartHeight + 15;
  addText(`Most probable outcome: |${counts.indexOf(maxCount).toString(2).padStart(numQubits, '0')}> with ${maxCount} counts.`, 10, 'normal');

  // --- Footer ---
  const pageCount = doc.getNumberOfPages();
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i);
    doc.setFontSize(8);
    doc.setTextColor(150);
    doc.text(`Page ${i} of ${pageCount}`, pageWidth - margin - 20, doc.internal.pageSize.height - 10);
  }

  // Save
  doc.save(`${projectTitle.replace(/\s+/g, '_')}_Report.pdf`);
};
