
import { jsPDF } from "jspdf";
import { Complex, Gate } from "../types";

interface ReportConfig {
  studentName: string;
  projectTitle: string;
  password?: string;
  amplitudes: Complex[];
  gates: (Gate | null)[][];
  numQubits: number;
}

export const generatePDFReport = (config: ReportConfig) => {
  const { studentName, projectTitle, password, amplitudes, gates, numQubits } = config;

  const doc = new jsPDF({
    encryption: password ? {
      userPassword: password,
      ownerPassword: password,
      userPermissions: ["print", "copy", "modify", "annot-forms"]
    } : undefined
  });

  const pageWidth = doc.internal.pageSize.width;
  const pageHeight = doc.internal.pageSize.height;
  const margin = 20;
  let y = 20;

  const addText = (text: string, size: number = 10, style: string = 'normal', color: string = '#000000', font: string = 'helvetica') => {
    doc.setFontSize(size);
    doc.setFont(font, style);
    doc.setTextColor(color);
    const lines = doc.splitTextToSize(text, pageWidth - margin * 2);
    doc.text(lines, margin, y);
    y += lines.length * (size * 0.4) + 2; 
  };

  const checkPageBreak = (neededSpace: number) => {
    if (y + neededSpace > pageHeight - margin) {
      doc.addPage();
      y = 20;
    }
  };

  const addSectionTitle = (title: string) => {
      checkPageBreak(15);
      y += 5;
      doc.setFontSize(14);
      doc.setFont("helvetica", "bold");
      doc.setTextColor(30, 41, 59); // Slate 800
      doc.text(title, margin, y);
      y += 8;
      // Underline
      doc.setDrawColor(56, 189, 248); // Light Blue
      doc.setLineWidth(0.5);
      doc.line(margin, y-2, margin + 20, y-2); 
      doc.setLineWidth(0.1);
  };

  // --- Statistics Calculation ---
  let gateCount = 0;
  let depth = 0;
  gates.forEach((step, i) => {
      const hasGate = step.some(g => g !== null);
      if(hasGate) depth = i + 1;
      step.forEach(g => { if(g) gateCount++; });
  });

  // --- QASM Generation ---
  let qasm = `OPENQASM 2.0;\ninclude "qelib1.inc";\nqreg q[${numQubits}];\ncreg c[${numQubits}];\n\n`;
  gates.forEach(step => {
      step.forEach(g => {
          if (!g) return;
          const t = g.target;
          const c = g.control;
          switch(g.type) {
              case 'H': qasm += `h q[${t}];\n`; break;
              case 'X': qasm += `x q[${t}];\n`; break;
              case 'Y': qasm += `y q[${t}];\n`; break;
              case 'Z': qasm += `z q[${t}];\n`; break;
              case 'S': qasm += `s q[${t}];\n`; break;
              case 'T': qasm += `t q[${t}];\n`; break;
              case 'CX': qasm += `cx q[${c}],q[${t}];\n`; break;
              case 'CZ': qasm += `cz q[${c}],q[${t}];\n`; break;
              case 'CY': qasm += `cy q[${c}],q[${t}];\n`; break;
              case 'CS': qasm += `cp(pi/2) q[${c}],q[${t}];\n`; break;
          }
      });
  });

  // --- Header ---
  doc.setFillColor(15, 23, 42); // Slate 950
  doc.rect(0, 0, pageWidth, 40, 'F');
  
  y = 18;
  doc.setFontSize(20);
  doc.setFont("helvetica", "bold");
  doc.setTextColor(255, 255, 255);
  doc.text("Quantum Experiment Report", margin, y);
  
  y += 8;
  doc.setFontSize(10);
  doc.setFont("helvetica", "normal");
  doc.setTextColor(148, 163, 184); // Slate 400
  doc.text("Generated by QuantumLens Environment", margin, y);

  y = 55;

  // --- 1. Experiment Overview ---
  addText(`Project: ${projectTitle}`, 16, 'bold', '#0f172a');
  y += 2;
  
  doc.setFontSize(10);
  doc.setTextColor(71, 85, 105);
  doc.text(`Researcher: ${studentName || "Anonymous"}`, margin, y);
  doc.text(`Date: ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString()}`, margin + 80, y);
  y += 8;

  // Stats Grid
  doc.setFillColor(241, 245, 249); // Slate 100
  doc.roundedRect(margin, y, pageWidth - margin*2, 25, 3, 3, 'F');
  
  const statsY = y + 10;
  doc.setFont("courier", "bold");
  doc.setFontSize(12);
  doc.setTextColor(30, 41, 59);
  
  doc.text(`${numQubits}`, margin + 20, statsY);
  doc.text(`${gateCount}`, margin + 70, statsY);
  doc.text(`${depth}`, margin + 120, statsY);
  
  doc.setFont("helvetica", "normal");
  doc.setFontSize(8);
  doc.setTextColor(100, 116, 139);
  doc.text("QUBITS", margin + 20, statsY + 6);
  doc.text("GATE COUNT", margin + 70, statsY + 6);
  doc.text("CIRCUIT DEPTH", margin + 120, statsY + 6);
  
  y += 35;

  // --- 2. Circuit Diagram ---
  addSectionTitle("2. Circuit Schematic");
  doc.setFont("courier", "normal");
  doc.setFontSize(8);
  doc.setTextColor(51, 65, 85);
  
  const schematicLines = [];
  for(let q = 0; q < numQubits; q++) {
      let line = `q[${q}] |0> ─`;
      gates.forEach(step => {
          const gate = step[q];
          const isControl = step.some(g => g?.control === q);
          if (gate) {
              line += `[${gate.type}${gate.control !== undefined ? `|c${gate.control}` : ''}]─`;
          } else if (isControl) {
              const targetGate = step.find(g => g?.control === q);
              line += `─●(t${targetGate?.target})─`;
          } else {
              line += `──────`;
          }
      });
      line += " M ║";
      schematicLines.push(line);
  }
  
  // Background for schematic
  const schHeight = schematicLines.length * 6 + 10;
  doc.setFillColor(248, 250, 252);
  doc.setDrawColor(226, 232, 240);
  doc.rect(margin, y, pageWidth - margin*2, schHeight, 'FD');
  
  y += 6;
  schematicLines.forEach(l => {
      doc.text(l, margin + 5, y);
      y += 6;
  });
  y += 10;

  // --- 3. Source Code (OpenQASM) ---
  checkPageBreak(60);
  addSectionTitle("3. OpenQASM 2.0 Code");
  
  doc.setFillColor(15, 23, 42); // Dark bg for code
  doc.rect(margin, y, pageWidth - margin*2, 40, 'F');
  
  doc.setFont("courier", "normal");
  doc.setFontSize(8);
  doc.setTextColor(34, 211, 238); // Cyan
  
  // Only print first few lines if too long, or wrap
  const qasmLines = doc.splitTextToSize(qasm, pageWidth - margin*2 - 10);
  // Limit to box height approx
  const maxLines = 10;
  doc.text(qasmLines.slice(0, maxLines), margin + 5, y + 6);
  if (qasmLines.length > maxLines) {
      doc.text("... (truncated)", margin + 5, y + 6 + (maxLines * 3.5));
  }
  y += 50;

  // --- 4. Mathematical Analysis ---
  checkPageBreak(40);
  addSectionTitle("4. Final State Vector");
  
  // Construct Dirac Notation
  const significantStates = amplitudes
    .map((amp, idx) => ({ idx, amp, prob: amp.r*amp.r + amp.i*amp.i }))
    .filter(s => s.prob > 0.0001);

  let diracStr = "|ψ⟩ = ";
  significantStates.forEach((s, i) => {
      const sign = s.amp.r >= 0 ? (i > 0 ? "+ " : "") : "- ";
      const valRe = Math.abs(s.amp.r);
      const valIm = s.amp.i;
      const term = valIm !== 0 ? `(${s.amp.r.toFixed(3)}${s.amp.i>=0?'+':''}${s.amp.i.toFixed(3)}i)` : `${sign}${valRe.toFixed(3)}`;
      diracStr += `${term}|${s.idx.toString(2).padStart(numQubits, '0')}⟩ `;
      if (i < significantStates.length - 1) diracStr += "  ";
  });

  doc.setFont("times", "italic");
  doc.setFontSize(11);
  doc.setTextColor(0, 0, 0);
  addText(diracStr);
  y += 5;

  // --- 5. Qubit Marginals ---
  checkPageBreak(50);
  addSectionTitle("5. Individual Qubit Analysis");
  
  // Table Header
  doc.setFont("helvetica", "bold");
  doc.setFontSize(9);
  doc.setFillColor(224, 242, 254); // Light Cyan
  doc.rect(margin, y, pageWidth - margin*2, 8, 'F');
  doc.setTextColor(23, 37, 84);
  doc.text("Qubit", margin + 5, y + 5.5);
  doc.text("P(|0⟩)", margin + 40, y + 5.5);
  doc.text("P(|1⟩)", margin + 80, y + 5.5);
  doc.text("State Description", margin + 120, y + 5.5);
  y += 10;

  doc.setFont("helvetica", "normal");
  doc.setTextColor(0);

  for (let q = 0; q < numQubits; q++) {
      let p1 = 0;
      for (let i = 0; i < amplitudes.length; i++) {
          if ((i & (1 << q)) !== 0) {
              const mag = amplitudes[i].r**2 + amplitudes[i].i**2;
              p1 += mag;
          }
      }
      const p0 = 1 - p1;
      
      doc.text(`q[${q}]`, margin + 5, y);
      doc.text(`${(p0 * 100).toFixed(1)}%`, margin + 40, y);
      doc.text(`${(p1 * 100).toFixed(1)}%`, margin + 80, y);
      
      let desc = "Superposition";
      if (p0 > 0.99) desc = "Definite |0⟩";
      else if (p1 > 0.99) desc = "Definite |1⟩";
      else if (Math.abs(p0 - 0.5) < 0.01) desc = "Maximally Uncertain";
      
      doc.text(desc, margin + 120, y);
      
      doc.setDrawColor(240);
      doc.line(margin, y+2, pageWidth - margin, y+2);
      y += 6;
  }
  y += 5;

  // --- 6. Full Basis Table ---
  checkPageBreak(60);
  addSectionTitle("6. Basis State Probabilities");
  
  // Header
  doc.setFont("helvetica", "bold");
  doc.setFillColor(241, 245, 249);
  doc.rect(margin, y, pageWidth - margin*2, 8, 'F');
  doc.text("Basis |x⟩", margin + 5, y + 5.5);
  doc.text("Probability", margin + 50, y + 5.5);
  doc.text("Phase (rad)", margin + 100, y + 5.5);
  doc.text("Amplitude", margin + 140, y + 5.5);
  y += 10;

  doc.setFont("helvetica", "normal");
  significantStates.forEach(s => {
      checkPageBreak(8);
      const phase = Math.atan2(s.amp.i, s.amp.r);
      const label = `|${s.idx.toString(2).padStart(numQubits, '0')}⟩`;
      
      doc.text(label, margin + 5, y);
      doc.text(`${(s.prob * 100).toFixed(4)}%`, margin + 50, y);
      doc.text(`${phase.toFixed(3)}`, margin + 100, y);
      doc.text(`${s.amp.r.toFixed(3)} ${s.amp.i >= 0 ? '+' : ''}${s.amp.i.toFixed(3)}i`, margin + 140, y);
      y += 6;
  });
  y += 5;

  // --- 7. Experimental Results ---
  checkPageBreak(80);
  addSectionTitle("7. Experimental Simulation (1024 Shots)");
  
  // Run simulation
  const shots = 1024;
  const counts = new Array(amplitudes.length).fill(0);
  const probs = amplitudes.map(c => c.r * c.r + c.i * c.i);
  const cdf = new Array(amplitudes.length).fill(0);
  cdf[0] = probs[0];
  for (let i = 1; i < probs.length; i++) cdf[i] = cdf[i - 1] + probs[i];

  for (let k = 0; k < shots; k++) {
      const r = Math.random();
      let outcome = probs.length - 1;
      for (let j = 0; j < probs.length - 1; j++) {
          if (r < cdf[j]) { outcome = j; break; }
      }
      counts[outcome]++;
  }

  // Draw Histogram
  const graphH = 50;
  const graphW = pageWidth - margin * 2;
  const barW = (graphW / probs.length) * 0.7;
  const maxCount = Math.max(...counts);
  
  doc.setDrawColor(0);
  doc.line(margin, y + graphH, margin + graphW, y + graphH); // X axis
  doc.line(margin, y, margin, y + graphH); // Y axis
  
  counts.forEach((c, i) => {
      if (c === 0 && probs.length > 32) return;
      const h = maxCount > 0 ? (c / maxCount) * (graphH - 5) : 0;
      const x = margin + 5 + i * (graphW / probs.length);
      
      doc.setFillColor(6, 182, 212); // Cyan 500
      doc.rect(x, y + graphH - h, barW, h, 'F');
      
      if (probs.length <= 16 || c > maxCount * 0.1) {
          doc.setFontSize(6);
          doc.setTextColor(100);
          const label = i.toString(2).padStart(numQubits, '0');
          doc.text(label, x + barW/2, y + graphH + 4, { align: "center", angle: 45 });
      }
  });
  
  y += graphH + 15;
  doc.setFontSize(10);
  doc.setTextColor(0);
  const winnerIdx = counts.indexOf(maxCount);
  const winnerLabel = winnerIdx.toString(2).padStart(numQubits, '0');
  addText(`Most probable outcome: |${winnerLabel}⟩ with ${maxCount}/${shots} counts (${((maxCount/shots)*100).toFixed(1)}%).`);

  // --- Footer ---
  const pageCount = doc.getNumberOfPages();
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i);
    doc.setFontSize(8);
    doc.setTextColor(150);
    doc.text(`Page ${i} of ${pageCount}`, pageWidth - margin - 20, pageHeight - 10);
  }

  doc.save(`${projectTitle.replace(/\s+/g, '_')}_Lab_Report.pdf`);
};
